#!/usr/bin/env bash
set -euo pipefail

invoke_malware () {
  echo "[Malware] Start"
Malware  
echo "[Malware] Done"
}


Malware() {

# Listening Malware Search
for pid in $(sudo ss -plnt | grep -oP 'pid=\K\d+' | sort -u); do cmdline=$(tr -d '\0' < /proc/$pid/cmdline 2>/dev/null); if [ -n "$cmdline" ]; then echo "PID: $pid - Command Line: $cmdline" >> "$DOCS/postmalware.txt"; fi; done


for pid in $(sudo ss -plnt | grep -oP 'pid=\K\d+' | sort -u); do
    # Get the command line associated with the PID
    cmdline=$(tr '\0' ' ' < /proc/$pid/cmdline 2>/dev/null)
    
    if [ -n "$cmdline" ]; then
		echo ""
        echo "PID: $pid - Command Line: $cmdline"
        
        # Get the executable or script path
        exe_file=$(readlink -f /proc/$pid/exe 2>/dev/null)
        
        if [ -n "$exe_file" ] && [ -f "$exe_file" ]; then
            # Check if the executable is an interpreter (Python, Perl, etc.)
            if [[ "$exe_file" == *python* || "$exe_file" == *perl* || "$exe_file" == *bash* || "$exe_file" == *sh* ]]; then
                # Extract the script file being executed
                script_file=$(echo "$cmdline" | awk '{print $2}')
                
                if [ -n "$script_file" ] && [ -f "$script_file" ]; then
                    echo "Interpreter: $exe_file"
                    echo -e "Script file: ${script_file}${NC}"
                    
                    # Prompt to remove the script file
                    read -p "Do you want to remove this script file? (Y/n) " answer
                    answer=${answer:-Y}
                    
                    if [[ "$answer" == "Y" || "$answer" == "y" ]]; then
                        echo "Removing $script_file..."
                        sudo rm -f "$script_file"
                        
                        if [ $? -eq 0 ]; then
                            echo "File $script_file removed successfully."
                        else
                            echo "Failed to remove $script_file."
                        fi
                    else
                        echo "Skipping removal of $script_file."
                    fi
                else
                    echo "No valid script file found."
                fi
            else
				echo -e "Executable file: ${RED}${exe_file}${NC}"                
                # Prompt to remove the executable
                read -p "Do you want to remove this file? (Y/n) " answer
                answer=${answer:-Y}
                
                if [[ "$answer" == "Y" || "$answer" == "y" ]]; then
                    echo "Removing $exe_file..."
                    sudo rm -f "$exe_file"
                    
                    if [ $? -eq 0 ]; then
                        echo "File $exe_file removed successfully."
                    else
                        echo "Failed to remove $exe_file."
                    fi
                else
                    echo "Skipping removal of $exe_file."
                fi
            fi
        else
            echo "Executable file not found or is not a regular file."
        fi
    fi
done
#!/usr/bin/env bash
# remove_backdoors_mint.sh
# Purpose: scan for common backdoor indicators on Linux Mint and quarantine+remove them
# WARNING: This is a best-effort remediation script. If you suspect compromise, isolate the host,
# collect logs/artifacts, and consider a full reinstall. This script creates backups of removed files.

set -u
IFS=$'\n\t'

LOG="/var/log/backdoor_removal.log"
QUAR="/var/backdoor_quarantine/$(date +%Y%m%d_%H%M%S)"
mkdir -p "$QUAR"
touch "$LOG"
exec > >(tee -a "$LOG") 2>&1

echo "=== Backdoor scan & removal started: $(date) ==="
echo "Quarantine directory: $QUAR"
echo

safe_run() {
  echo "+ $*"
  "$@" || echo "  (failed:$?) $*"
}

# Ensure we run as root
if [ "$(id -u)" -ne 0 ]; then
  echo "This script must be run as root. Exiting."
  exit 1
fi

# Utility: back up a file before removal
backup_and_remove() {
  local f="$1"
  local dest="$QUAR$(dirname "$f")"
  mkdir -p "$dest"
  if [ -e "$f" ]; then
    cp -a "$f" "$dest/" 2>/dev/null || true
    rm -f "$f" || echo "Could not remove $f"
    echo "Backed up and removed: $f"
  fi
}

# 1) Detect and stop suspicious listeners (netcat-like, reverse-shell patterns)
echo "[1] Detecting network listeners that look suspicious..."
safe_run ss -tulpn | tee /tmp/backdoor_ss.out
grep -Ei 'nc|ncat|netcat|bash|sh|perl|python|ruby' /tmp/backdoor_ss.out || true

# Kill processes that have suspicious command lines
echo
echo "[2] Finding suspicious processes by commandline patterns..."
suspicious_procs=$(ps ax -o pid= -o user= -o args= | grep -Ei '(^|/)(nc|ncat|netcat)\b|bash -i >& /dev/tcp|/dev/tcp/|mkfifo .*; /bin/sh' | awk '{print $1}' | sort -u || true)
if [ -n "$suspicious_procs" ]; then
  echo "Suspicious PIDs: $suspicious_procs"
  for pid in $suspicious_procs; do
    safe_run kill -9 "$pid" || echo "Could not kill $pid"
  done
else
  echo "No obvious suspicious PIDs found by common patterns."
fi

# Also try pkill by common names (best-effort)
safe_run pkill -9 -f '(?:^|/)(?:nc|ncat|netcat)\b' || true

# 3) Remove transient/backdoor binaries from writable runtime dirs
echo
echo "[3] Scanning writable runtime directories for suspicious executables..."
runtime_dirs=(/tmp /var/tmp /dev/shm /run /run/user)
for d in "${runtime_dirs[@]}"; do
  [ -d "$d" ] || continue
  find "$d" -maxdepth 3 -type f -executable \( -iname 'nc' -o -iname 'ncat*' -o -iname '*netcat*' -o -iname 'socat' -o -iname 'r.sh' \) -print |
    while read -r f; do
      echo "Quarantining runtime executable: $f"
      backup_and_remove "$f"
    done
  # also search binaries containing netcat strings
  grep -Ial --binary-files=without-match -E 'netcat|ncat|nc -l|nc -e|/dev/tcp' "$d"/* 2>/dev/null | while read -r f; do
    [ -f "$f" ] && { echo "Quarantining matched file: $f"; backup_and_remove "$f"; }
  done || true
done

# 4) Remove package-managed netcat variants
echo
echo "[4] Removing package-managed netcat variants (apt)"
safe_run apt-get update -qq || true
for pkg in netcat-openbsd netcat-traditional openbsd-netcat ncat socat; do
  if dpkg -l | grep -q "^ii\s\+$pkg\b"; then
    echo "Purging package: $pkg"
    safe_run DEBIAN_FRONTEND=noninteractive apt-get -y purge "$pkg" || true
  fi
done
safe_run apt-get -y autoremove || true
safe_run apt-get -y autoclean || true

# 5) Check /usr/bin /bin /usr/local/bin for unowned suspicious binaries
echo
echo "[5] Checking standard binary locations for unowned/strange nc-like executables..."
candidates=(/usr/bin/nc /bin/nc /usr/local/bin/nc /usr/bin/ncat /usr/local/bin/ncat /usr/bin/netcat /usr/bin/socat)
for f in "${candidates[@]}"; do
  if [ -f "$f" ]; then
    if dpkg -S "$f" >/dev/null 2>&1; then
      echo "File $f belongs to a package; skipping removal (package-managed)."
    else
      echo "Unowned suspicious binary found: $f -> quarantining"
      backup_and_remove "$f"
    fi
  fi
done

# 6) Search for persistence: cron, systemd, rc.local, user startup
echo
echo "[6] Searching for persistence references to known backdoor patterns..."
persistence_patterns='nc|ncat|netcat|/dev/tcp|bash -i >&|/bin/bash -i|mkfifo|socat|perl -e|python -c "import socket"|/usr/local/bin/shell'
paths_to_search=(/etc /root /home /var/spool/cron /etc/cron.* /etc/systemd /lib/systemd /usr/lib/systemd /etc/init.d)
for p in "${paths_to_search[@]}"; do
  [ -e "$p" ] || continue
  echo "Searching $p ..."
  grep -RIn --exclude-dir={/proc,/sys,/dev,/run,/var/lib/docker} -E "$persistence_patterns" "$p" 2>/dev/null || true
done

# Clean cron files mentioning patterns (backup then delete offending lines)
echo
echo "[7] Cleaning system cron files that mention backdoor patterns (best-effort backups made)"
cron_files=(/etc/crontab /etc/cron.d/*)
for cf in "${cron_files[@]}"; do
  [ -e "$cf" ] || continue
  if grep -IqE "$persistence_patterns" "$cf"; then
    echo "Backing up $cf -> ${cf}.bak.backdoor"
    cp -a "$cf" "${cf}.bak.backdoor" || true
    sed -i -E "/$persistence_patterns/Id" "$cf" || true
    echo "Cleaned $cf"
  fi
done

# Clean per-user crontabs
if [ -d /var/spool/cron/crontabs ]; then
  for ucron in /var/spool/cron/crontabs/*; do
    [ -f "$ucron" ] || continue
    if grep -IqE "$persistence_patterns" "$ucron"; then
      echo "Backing up and cleaning $ucron"
      cp -a "$ucron" "${ucron}.bak.backdoor" || true
      sed -i -E "/$persistence_patterns/Id" "$ucron" || true
    fi
  done
fi

# rc.local
if [ -f /etc/rc.local ]; then
  if grep -IqE "$persistence_patterns" /etc/rc.local; then
    echo "Backing up and cleaning /etc/rc.local"
    cp -a /etc/rc.local /etc/rc.local.bak.backdoor || true
    sed -i -E "/$persistence_patterns/Id" /etc/rc.local || true
  fi
fi

# 8) Find systemd units containing backdoor patterns and remove/disable them
echo
echo "[8] Inspecting systemd unit files for suspicious references..."
mapfile -t bad_units < <(grep -RIl --exclude-dir={/proc,/sys,/dev} -E "$persistence_patterns" /etc/systemd /lib/systemd /usr/lib/systemd 2>/dev/null || true)
if [ ${#bad_units[@]} -gt 0 ]; then
  for ufile in "${bad_units[@]}"; do
    unitname=$(basename "$ufile")
    echo "Suspicious unit found: $ufile (unit: $unitname)"
    safe_run systemctl stop "$unitname" || true
    safe_run systemctl disable "$unitname" || true
    backup_and_remove "$ufile"
  done
  safe_run systemctl daemon-reload || true
else
  echo "No suspicious systemd unit files found."
fi

# 9) Clean user startup files (.bashrc, .profile, autostart .desktop)
echo
echo "[9] Scanning user startup files for backdoor references..."
for userdir in /root /home/*; do
  [ -d "$userdir" ] || continue
  for f in .bashrc .profile .bash_profile .bash_login .xsession .xinitrc; do
    target="$userdir/$f"
    if [ -f "$target" ] && grep -IqE "$persistence_patterns" "$target"; then
      echo "Backing up and cleaning $target"
      cp -a "$target" "${target}.bak.backdoor" || true
      sed -i -E "/$persistence_patterns/Id" "$target" || true
    fi
  done
  # autostart desktops
  if [ -d "$userdir/.config/autostart" ]; then
    for desktop in "$userdir/.config/autostart"/*.desktop; do
      [ -f "$desktop" ] || continue
      if grep -IqE "$persistence_patterns" "$desktop"; then
        echo "Quarantining autostart .desktop: $desktop"
        backup_and_remove "$desktop"
      fi
    done
  fi
done

# 10) Search for suspicious SUID/SGID/executable files in writable locations
echo
echo "[10] Listing suspicious SUID/SGID files (manual review recommended)"
find / -xdev \( -perm -4000 -o -perm -2000 \) -type f -print 2>/dev/null | tee /tmp/suid_list.out
echo "If any binaries in /tmp, /var/tmp, /dev/shm, /usr/local/bin are SUID/SGID, investigate."

# 11) Grep for common reverse-shell one-liners through likely directories
echo
echo "[11] Grepping for reverse-shell patterns in candidate directories..."
for dir in /etc /root /home /var /opt /usr/local; do
  [ -d "$dir" ] || continue
  grep -RIl --exclude-dir={/proc,/sys,/dev,/run} -E 'bash -i >& /dev/tcp|/dev/tcp/[0-9]|python -c "import socket"|mkfifo.*sh|perl -e.*socket' "$dir" 2>/dev/null | while read -r f; do
    echo "Suspicious file with reverse-shell pattern: $f"
    backup_and_remove "$f"
  done || true
done

# 12) Flatpak & Snap: remove apps that match backdoor names
echo
echo "[12] Checking Flatpak and Snap installations for suspicious apps..."
if command -v flatpak >/dev/null 2>&1; then
  flatpak list --app --columns=application | grep -Ei 'nc|ncat|netcat|socat' | while read -r app; do
    echo "Removing Flatpak app: $app"
    safe_run flatpak uninstall -y "$app" || true
  done || true
fi

if command -v snap >/dev/null 2>&1; then
  snap list 2>/dev/null | awk 'NR>1{print $1}' | grep -Ei 'nc|ncat|netcat|socat' | while read -r s; do
    echo "Removing snap: $s"
    safe_run snap remove --purge "$s" || true
  done || true
fi

# 13) Final network/listener check
echo
echo "[13] Final listener check (post-cleanup):"
safe_run ss -tulpn | grep -Ei 'nc|ncat|netcat|bash|sh|python|perl|socat' || echo "No obvious listeners matching patterns."
echo
echo "=== End ==="
}
