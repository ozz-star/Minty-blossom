#!/usr/bin/env bash
set -euo pipefail

invoke_malware () {
  echo "[Malware] Start"
Malware  
echo "[Malware] Done"
}


Malware() {

# Listening Malware Search
for pid in $(sudo ss -plnt | grep -oP 'pid=\K\d+' | sort -u); do cmdline=$(tr -d '\0' < /proc/$pid/cmdline 2>/dev/null); if [ -n "$cmdline" ]; then echo "PID: $pid - Command Line: $cmdline" >> "$DOCS/postmalware.txt"; fi; done


for pid in $(sudo ss -plnt | grep -oP 'pid=\K\d+' | sort -u); do
    # Get the command line associated with the PID
    cmdline=$(tr '\0' ' ' < /proc/$pid/cmdline 2>/dev/null)
    
    if [ -n "$cmdline" ]; then
		echo ""
        echo "PID: $pid - Command Line: $cmdline"
        
        # Get the executable or script path
        exe_file=$(readlink -f /proc/$pid/exe 2>/dev/null)
        
        if [ -n "$exe_file" ] && [ -f "$exe_file" ]; then
            # Check if the executable is an interpreter (Python, Perl, etc.)
            if [[ "$exe_file" == *python* || "$exe_file" == *perl* || "$exe_file" == *bash* || "$exe_file" == *sh* ]]; then
                # Extract the script file being executed
                script_file=$(echo "$cmdline" | awk '{print $2}')
                
                if [ -n "$script_file" ] && [ -f "$script_file" ]; then
                    echo "Interpreter: $exe_file"
                    echo -e "Script file: ${BOLD_RED}${script_file}${NC}"
                    
                    # Prompt to remove the script file
                    read -p "Do you want to remove this script file? (Y/n) " answer
                    answer=${answer:-Y}
                    
                    if [[ "$answer" == "Y" || "$answer" == "y" ]]; then
                        echo "Removing $script_file..."
                        sudo rm -f "$script_file"
                        
                        if [ $? -eq 0 ]; then
                            echo "File $script_file removed successfully."
                        else
                            echo "Failed to remove $script_file."
                        fi
                    else
                        echo "Skipping removal of $script_file."
                    fi
                else
                    echo "No valid script file found."
                fi
            else
				echo -e "Executable file: ${RED}${exe_file}${NC}"                
                # Prompt to remove the executable
                read -p "Do you want to remove this file? (Y/n) " answer
                answer=${answer:-Y}
                
                if [[ "$answer" == "Y" || "$answer" == "y" ]]; then
                    echo "Removing $exe_file..."
                    sudo rm -f "$exe_file"
                    
                    if [ $? -eq 0 ]; then
                        echo "File $exe_file removed successfully."
                    else
                        echo "Failed to remove $exe_file."
                    fi
                else
                    echo "Skipping removal of $exe_file."
                fi
            fi
        else
            echo "Executable file not found or is not a regular file."
        fi
    fi
done
#!/usr/bin/env bash
set -euo pipefail

LOG=/var/log/remove_nc_backdoor.log
exec > >(tee -a "$LOG") 2>&1

echo "=== Netcat-backdoor cleanup started: $(date) ==="

# Helper: safe run
run() { echo "+ $*"; "$@" || echo "  (failed:$?) $*"; }

# 1) Show and kill listening netcat-like processes (nc, ncat, netcat, busybox sh -c '...nc...')
echo
echo "[1] Detecting TCP/UDP listeners that look like netcat..."
run ss -tulpn | grep -Ei 'nc|ncat|netcat|ncat|busybox' || echo "No obvious nc listeners found."

# Kill processes whose command line contains netcat keywords
echo
echo "[2] Killing processes with suspicious names/command-lines..."
# list PIDs first for logging
pids=$(ps ax -o pid= -o args= | grep -Ei '(^|/)(nc|ncat|netcat)(\s|$|:|-)' | awk '{print $1}' | sort -u || true)
if [ -n "$pids" ]; then
  echo "Found suspicious PIDs: $pids"
  for pid in $pids; do
    run kill -9 "$pid" || echo "Could not kill $pid"
  done
else
  echo "No suspicious netcat processes found by ps."
fi

# Also try pkill by pattern (best-effort)
run pkill -9 -f '(?:^|/)(?:nc|ncat|netcat)\b' || true

# 3) Remove obvious transient binaries from writable areas
echo
echo "[3] Removing nc/ncat binaries from /tmp, /var/tmp, /dev/shm, /run..."
for d in /tmp /var/tmp /dev/shm /run ; do
  if [ -d "$d" ]; then
    find "$d" -maxdepth 2 -type f -executable \( -iname 'nc' -o -iname 'ncat*' -o -iname '*netcat*' \) -print -exec rm -f {} \; || true
    # also remove files that contain "netcat" string (text/binary) - best-effort
    find "$d" -maxdepth 2 -type f -exec grep -Ia 'netcat\|ncat\|nc -l\|nc -e' {} \; -print -exec rm -f {} \; 2>/dev/null || true
  fi
done

# 4) Uninstall package-managed netcat variants
echo
echo "[4] Uninstalling packaged netcat variants (apt)..."
run apt-get update -qq || true
run apt-get -y purge netcat-openbsd netcat-traditional openbsd-netcat ncat || true
run apt-get -y autoremove || true
run apt-get -y autoclean || true

# 5) If /usr/bin/nc exists and isn't from a package, remove it
echo
echo "[5] Checking /usr/bin /bin /usr/local/bin for stray nc binaries..."
candidates="/usr/bin/nc /bin/nc /usr/local/bin/nc /usr/bin/ncat /usr/local/bin/ncat /usr/bin/netcat"
for f in $candidates; do
  if [ -f "$f" ]; then
    if dpkg -S "$f" >/dev/null 2>&1; then
      echo "File $f belongs to a package (left in place):"
      dpkg -S "$f" || true
    else
      echo "Removing unowned file $f"
      run rm -f "$f" || true
    fi
  fi
done

# 6) Search for persistence lines (cron, @reboot, rc.local, systemd services, user .bashrc/.profile)
echo
echo "[6] Searching for persistence references to nc/ncat/netcat..."
paths_to_search=(/etc /root /home /var/spool/cron /var/spool/cron/crontabs /etc/cron.* /etc/systemd /lib/systemd /usr/lib/systemd)
for p in "${paths_to_search[@]}"; do
  if [ -e "$p" ]; then
    run grep -RIn --include='*' -E '(^|/)(nc|ncat|netcat)\b' "$p" || true
  fi
done

# Remove lines from system crontabs and /etc/cron.* files that mention nc
echo
echo "[7] Removing crontab/system cron entries that mention nc/ncat/netcat (best-effort)..."
# system-wide cron files
for cf in /etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.weekly/* /etc/cron.monthly/*; do
  [ -e "$cf" ] || continue
  if grep -IqE 'nc|ncat|netcat' "$cf"; then
    echo "Cleaning $cf"
    # create a backup then remove lines
    cp -a "$cf" "${cf}.bak.removencclean" || true
    sed -i '/nc\|ncat\|netcat/Id' "$cf" || true
  fi
done

# crontabs in /var/spool/cron/crontabs
if [ -d /var/spool/cron/crontabs ]; then
  for usercron in /var/spool/cron/crontabs/*; do
    [ -f "$usercron" ] || continue
    if grep -IqE 'nc|ncat|netcat' "$usercron"; then
      echo "Cleaning $usercron"
      cp -a "$usercron" "${usercron}.bak.removencclean" || true
      sed -i '/nc\|ncat\|netcat/Id' "$usercron" || true
    fi
  done
fi

# Remove anything in /etc/rc.local that mentions nc
if [ -f /etc/rc.local ]; then
  if grep -IqE 'nc|ncat|netcat' /etc/rc.local; then
    echo "Cleaning /etc/rc.local (backup created)"
    cp -a /etc/rc.local /etc/rc.local.bak.removencclean || true
    sed -i '/nc\|ncat\|netcat/Id' /etc/rc.local || true
  fi
fi

# 8) Inspect systemd units that reference nc and disable+remove them
echo
echo "[8] Disabling and removing systemd units referencing nc/ncat/netcat..."
# find unit files containing references
mapfile -t bad_units < <(grep -RIl --exclude-dir=/proc --exclude-dir=/sys -E 'nc\|ncat\|netcat' /etc/systemd /lib/systemd /usr/lib/systemd 2>/dev/null || true)
for ufile in "${bad_units[@]}"; do
  echo "Found unit file: $ufile"
  # try to determine unit name
  unitname=$(basename "$ufile")
  echo "Attempting to stop/disable $unitname"
  run systemctl stop "$unitname" || true
  run systemctl disable "$unitname" || true
  echo "Removing $ufile"
  run rm -f "$ufile" || true
done
# reload daemon after removals
run systemctl daemon-reload || true

# 9) Remove user-level persistence (.bashrc, .profile, .xsession, ~/.config/autostart)
echo
echo "[9] Cleaning user shell/startup files in /root and /home for netcat calls..."
for userdir in /root /home/*; do
  [ -d "$userdir" ] || continue
  for file in .bashrc .profile .bash_profile .bash_login .xsession .xinitrc .config/autostart/*.desktop; do
    target="$userdir/$file"
    if [ -e "$target" ]; then
      if grep -IqE 'nc\|ncat\|netcat' "$target"; then
        echo "Backing up and cleaning $target"
        cp -a "$target" "${target}.bak.removencclean" || true
        sed -i '/nc\|ncat\|netcat/Id' "$target" || true
      fi
    fi
  done
done

# 10) Look for suspicious SUID/SGID files that might be backdoors (best-effort)
echo
echo "[10] Listing recently modified executable files in world-writable dirs (for manual review)..."
find /tmp /var/tmp /dev/shm -type f -executable -printf '%TY-%Tm-%Td %TT %p\n' | sort -r | head -n 50 || true

echo
echo "[11] Searching system for files mentioning netcat strings (this may take a while)..."
# limit to likely places to avoid scanning whole disk
run grep -RIl --exclude-dir={/proc,/sys,/dev,/run,/var/lib/docker} -E 'netcat|ncat|nc -l|nc -e' /etc /root /home /var 2>/dev/null || true

# 12) Final checks and recommendations
echo
echo "Final listener check:"
run ss -tulpn | grep -Ei 'nc|ncat|netcat|bash|sh' || echo "No obvious leftover listeners."

echo
echo "=== Done: $(date) ==="

}
