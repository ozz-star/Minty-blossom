#!/usr/bin/env bash
set -euo pipefail

invoke_malware () {
  echo "[Malware] Start"
Malware  
echo "[Malware] Done"
}


Malware() {

# Listening Malware Search
for pid in $(sudo ss -plnt | grep -oP 'pid=\K\d+' | sort -u); do cmdline=$(tr -d '\0' < /proc/$pid/cmdline 2>/dev/null); if [ -n "$cmdline" ]; then echo "PID: $pid - Command Line: $cmdline" >> "$DOCS/postmalware.txt"; fi; done


for pid in $(sudo ss -plnt | grep -oP 'pid=\K\d+' | sort -u); do
    # Get the command line associated with the PID
    cmdline=$(tr '\0' ' ' < /proc/$pid/cmdline 2>/dev/null)
    
    if [ -n "$cmdline" ]; then
		echo ""
        echo "PID: $pid - Command Line: $cmdline"
        
        # Get the executable or script path
        exe_file=$(readlink -f /proc/$pid/exe 2>/dev/null)
        
        if [ -n "$exe_file" ] && [ -f "$exe_file" ]; then
            # Check if the executable is an interpreter (Python, Perl, etc.)
            if [[ "$exe_file" == *python* || "$exe_file" == *perl* || "$exe_file" == *bash* || "$exe_file" == *sh* ]]; then
                # Extract the script file being executed
                script_file=$(echo "$cmdline" | awk '{print $2}')
                
                if [ -n "$script_file" ] && [ -f "$script_file" ]; then
                    echo "Interpreter: $exe_file"
                    echo -e "Script file: ${script_file}${NC}"
                    
                    # Prompt to remove the script file
                    read -p "Do you want to remove this script file? (Y/n) " answer
                    answer=${answer:-Y}
                    
                    if [[ "$answer" == "Y" || "$answer" == "y" ]]; then
                        echo "Removing $script_file..."
                        sudo rm -f "$script_file"
                        
                        if [ $? -eq 0 ]; then
                            echo "File $script_file removed successfully."
                        else
                            echo "Failed to remove $script_file."
                        fi
                    else
                        echo "Skipping removal of $script_file."
                    fi
                else
                    echo "No valid script file found."
                fi
            else
				echo -e "Executable file: ${RED}${exe_file}${NC}"                
                # Prompt to remove the executable
                read -p "Do you want to remove this file? (Y/n) " answer
                answer=${answer:-Y}
                
                if [[ "$answer" == "Y" || "$answer" == "y" ]]; then
                    echo "Removing $exe_file..."
                    sudo rm -f "$exe_file"
                    
                    if [ $? -eq 0 ]; then
                        echo "File $exe_file removed successfully."
                    else
                        echo "Failed to remove $exe_file."
                    fi
                else
                    echo "Skipping removal of $exe_file."
                fi
            fi
        else
            echo "Executable file not found or is not a regular file."
        fi
    fi
done
#!/usr/bin/env bash
# remove_backdoors_mint_simple.sh
# Simplified backdoor scan & removal for Linux Mint.
# Creates a quarantine of removed files. Run as root.
set -euo pipefail
IFS=$'\n\t'

LOG="/var/log/backdoor_removal.log"
QUAR="/var/backdoor_quarantine/$(date +%Y%m%d_%H%M%S)"
mkdir -p "$QUAR"
touch "$LOG"
exec > >(tee -a "$LOG") 2>&1

echo "=== Backdoor scan & removal started: $(date) ==="
echo "Quarantine: $QUAR"
echo

if [ "$(id -u)" -ne 0 ]; then
  echo "Must be run as root. Exiting."
  exit 1
fi

safe_run() {
  echo "+ $*"
  "$@" || echo "  (failed:$?) $*"
}

backup_and_remove() {
  local f="$1"
  [ -e "$f" ] || return
  local dest="$QUAR$(dirname "$f")"
  mkdir -p "$dest"
  cp -a "$f" "$dest" 2>/dev/null || true
  rm -f "$f" || echo "Could not remove $f"
  echo "Quarantined: $f"
}

# 1) Show active listeners (log)
echo "[1] Listening sockets:"
ss -tulpn | tee /tmp/backdoor_listeners.out || true
grep -Ei 'nc|ncat|netcat|socat|bash|sh|python|perl' /tmp/backdoor_listeners.out || true

# 2) Kill suspicious processes by common patterns
echo
echo "[2] Killing suspicious processes (nc, ncat, netcat, socat and common reverse-shell one-liners)..."
suspicious_pids=$(ps ax -o pid= -o args= | grep -Ei '(^|/)(nc|ncat|netcat|socat)\b|bash -i >& /dev/tcp|/dev/tcp/|mkfifo .*; /bin/sh' | awk '{print $1}' | sort -u || true)
if [ -n "$suspicious_pids" ]; then
  for pid in $suspicious_pids; do
    safe_run kill -9 "$pid" || true
  done
else
  echo "No suspicious PIDs found by patterns."
fi
safe_run pkill -9 -f '(?:^|/)(?:nc|ncat|netcat|socat)\b' || true

# 3) Quarantine suspicious executables in writable runtime dirs (FIXED)
echo
echo "[3] Scanning runtime dirs for suspicious executables..."
runtime_dirs=(/tmp /var/tmp /dev/shm /run)

for d in "${runtime_dirs[@]}"; do
  [ -d "$d" ] || continue
  echo "Checking $d ..."

  # Find executable files with suspicious names
  find "$d" -maxdepth 2 -type f -executable \
    \( -iname 'nc' -o -iname 'ncat*' -o -iname '*netcat*' -o -iname 'socat' \) \
    -print0 2>/dev/null |
  while IFS= read -r -d '' f; do
    backup_and_remove "$f"
  done

  # Search text files only (skip binaries)
  find "$d" -maxdepth 2 -type f -size -2M 2>/dev/null | while read -r f; do
    if file "$f" | grep -qE 'text|script'; then
      if grep -qE 'netcat|ncat|nc -l|nc -e|/dev/tcp' "$f" 2>/dev/null; then
        backup_and_remove "$f"
      fi
    fi
  done
done

# 4) Purge common netcat/socat packages (APT)
echo
echo "[4] Purging package-managed netcat/socat variants..."
safe_run apt-get update -qq || true
for pkg in netcat-openbsd netcat-traditional openbsd-netcat ncat socat; do
  if dpkg -l 2>/dev/null | grep -q "^ii\s\+$pkg\b"; then
    safe_run DEBIAN_FRONTEND=noninteractive apt-get -y purge "$pkg" || true
  fi
done
safe_run apt-get -y autoremove || true
safe_run apt-get -y autoclean || true

# 5) Remove unowned nc-like binaries in standard locations
echo
echo "[5] Checking standard bin dirs for unowned suspicious binaries..."
candidates=(/usr/bin/nc /bin/nc /usr/local/bin/nc /usr/bin/ncat /usr/local/bin/ncat /usr/bin/netcat /usr/bin/socat)
for f in "${candidates[@]}"; do
  if [ -f "$f" ]; then
    if dpkg -S "$f" >/dev/null 2>&1; then
      echo "Package-owned: $f (skipped)"
    else
      backup_and_remove "$f"
    fi
  fi
done

# 6) Clean cron/system cron.d entries containing suspicious patterns
echo
echo "[6] Cleaning cron files with backdoor patterns..."
patterns='nc|ncat|netcat|/dev/tcp|bash -i >&|/bin/bash -i|mkfifo|socat|python -c|perl -e'
for cf in /etc/crontab /etc/cron.d/*; do
  [ -e "$cf" ] || continue
  if grep -IqE "$patterns" "$cf"; then
    cp -a "$cf" "${cf}.bak.backdoor" || true
    sed -i -E "/$patterns/Id" "$cf" || true
    echo "Cleaned $cf"
  fi
done

if [ -d /var/spool/cron/crontabs ]; then
  for ucron in /var/spool/cron/crontabs/*; do
    [ -f "$ucron" ] || continue
    if grep -IqE "$patterns" "$ucron"; then
      cp -a "$ucron" "${ucron}.bak.backdoor" || true
      sed -i -E "/$patterns/Id" "$ucron" || true
      echo "Cleaned $ucron"
    fi
  done
fi

# 7) Disable/remove systemd units that reference suspicious patterns
echo
echo "[7] Inspecting systemd unit files for suspicious references..."
mapfile -t bad_units < <(grep -RIl --exclude-dir={/proc,/sys,/dev} -E "$patterns" /etc/systemd /lib/systemd /usr/lib/systemd 2>/dev/null || true)
for ufile in "${bad_units[@]}"; do
  unitname=$(basename "$ufile")
  safe_run systemctl stop "$unitname" || true
  safe_run systemctl disable "$unitname" || true
  backup_and_remove "$ufile"
done
safe_run systemctl daemon-reload || true

# 8) Clean user startup files (.bashrc, .profile, autostart .desktop)
echo
echo "[8] Scanning user startup files for backdoor patterns..."
for userdir in /root /home/*; do
  [ -d "$userdir" ] || continue
  for f in .bashrc .profile .bash_profile .bash_login .xsession .xinitrc; do
    target="$userdir/$f"
    if [ -f "$target" ] && grep -IqE "$patterns" "$target"; then
      cp -a "$target" "${target}.bak.backdoor" || true
      sed -i -E "/$patterns/Id" "$target" || true
      echo "Cleaned $target"
    fi
  done
  if [ -d "$userdir/.config/autostart" ]; then
    for desktop in "$userdir/.config/autostart"/*.desktop; do
      [ -f "$desktop" ] || continue
      if grep -IqE "$patterns" "$desktop"; then
        backup_and_remove "$desktop"
      fi
    done
  fi
done

# 9) Flatpak & Snap removals (if present)
echo
echo "[9] Checking Flatpak/Snap for suspicious apps..."
if command -v flatpak >/dev/null 2>&1; then
  flatpak list --app --columns=application | grep -Ei 'nc|ncat|netcat|socat' | while read -r app; do
    safe_run flatpak uninstall -y "$app" || true
  done || true
fi

if command -v snap >/dev/null 2>&1; then
  snap list 2>/dev/null | awk 'NR>1{print $1}' | grep -Ei 'nc|ncat|netcat|socat' | while read -r s; do
    safe_run snap remove --purge "$s" || true
  done || true
fi

# 10) Final listener check
echo
echo "[10] Final listener check:"
ss -tulpn | tee /tmp/backdoor_listeners_after.out || true
grep -Ei 'nc|ncat|netcat|socat|bash|sh|python|perl' /tmp/backdoor_listeners_after.out || true

echo
echo "=== Done: $(date) ==="
echo "Log: $LOG"
echo "Quarantine: $QUAR"

}
